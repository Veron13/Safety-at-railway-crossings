                                               %          Железнодорожная сеть(Задача линейного программирования)           

%   DATA:
clc
clear all

N = 10; % - количество транспортных переездов;
save N N;

ne = [11 20 100 35 9 8 5 20 50 60]; % - количество железнодорожных составов, которые пересекают i-ый транспортный переезд;

T = 1; % - задаём промежуток времени, за который пересекают поезда наши ж/д переезды;
ne=ne*T;

save ne ne;

U0 = [1 2 1 2 1 1 1 2 4 4]; % -  системы типов от 0 до j, которые изначально были установлены на i-ом транспортном переезде;
save U0 U0;

% ========================================================================================================================

% Отсортируем системы по уровню безопасности Pi(j+1) < Pij и Ci(j+1) > Cij

j = 8; % - виды систем j, которые предотвращают несанкционированный переезд;
save j j;

Pij0 = [0.0005; 0.00001; 0.000008; 0.000006; 0.000002; 0.000001; 0.0000005; 0]; % - вероятности столкновения поезда с автотранспортом на i-ом транспортном переезде, использую систему j;
save Pij0 Pij0;

Cij0 = [0, 0.6, 0.7, 0.9, 1, 1.2, 1.5, 800]; % - изначальные расходы на приобретение и установку системы j составляют Cij на i-ом транспортном переезде;
save Cij0 Cij0;

% =========================================================================================================================
                                                                                                
C = 2; % - общий фонд инвестиций, который выделен для приобретения систем на железнодорожные переезды, чтобы уменьшить количество столкновений;
   
lb = zeros(N*(j+1),1);

ub = ones(N*(j+1),1);
for i = (N*j)+1:1:N*(j+1)
ub(i) = j;
end

gamma = -20;
save gamma gamma;
%==========================================================================
%  PROCEDURE:

disp('Задаётся матрица Pij')

load Pij Pij;
Pij
%==========================================================================

disp('Задаётся матрица Cij')

load('Cij.mat');
Cij
%==========================================================================

disp('Задаём тип переменных - целочисленный')

for type = 1:1:N*(j+1)
xtype(type) = 'I';
end
xtype
% =========================================================================

disp('Минимальная стоимость на расходы для повышения безопасности движения')

Cmin = 0;
for i = 1:1:N
    if U0(i) == 0
      Cmin = Cmin + Cij0(1);  
    end
end
Cmin % - отображается минимальная стоимость для повышения надёжности железнодорожной сети;

if C > Cmin % проверка на наличие финансовых инвестиций, которые могут покрыть минимальные расходы
disp(''); 
else 
if C < Cmin 
error('Недостаточно средств, чтобы повысить безопасность на всей железнодорожной сети')
end 
end 
%==========================================================================

load Cij1 Cij1;

Beq1 = ones(N,1); % -  ограничение для поиска Uij при условии равенства;
for i = N+1:1:2*N
Beq1(i) = 0;
end
Beq1;

itf = [-inf; 0];
Beq2 = [C; 0]; % -  ограничение для поиска Uij при условии неравенства;
for i = 1:1:N
Beq2(i+1) = -U0(i);
itf(i+1) = -inf;
end
Beq2;

% - задаём полную матрицу значений с Aeq и Beq
load Aeq1 Aeq1
load Aeq2 Aeq2

A = [Aeq2; Aeq1]; 
rl = [itf; Beq1];
ru = [Beq2; Beq1];
U = [];
for inter=1:1:(j+1)*N
   U = [U; 0];
end
%==========================================================================
% RESULTS:

disp('Ищем минимум целевой функции с помощью метода SCIP')
opts = optiset('solver','scip','display','iter');
Opt = opti('fun',@CreatePij,'lin',A,rl,ru,'bounds',lb,ub,'xtype',xtype,'opts',opts)

disp('Системы защиты')
[x,fval,exitflag,info] = solve(Opt,U)
Uij = x

for i=1:1:N
       disp('Номер транспортного переезда:')
    disp(i)
    disp('Тип системы защиты:')
    disp(Uij(N*j+i))
end

disp('Минимальное количество столкновений')
Mmin = fval
